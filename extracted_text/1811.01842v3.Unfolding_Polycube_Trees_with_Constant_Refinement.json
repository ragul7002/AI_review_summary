{
  "introduction": "An _unfolding_ of a polyhedron is obtained by cutting its surface in such a way that it can be flattened in\nthe plane as a simple non-overlapping polygon called a _net_ . An _edge unfolding_ allows only cuts along the\npolyhedron’s edges, while a _general unfolding_ allows cuts anywhere on the surface. Edge cuts alone are not\nsufficient to guarantee an unfolding for non-convex polyhedra [BDE [+] 03, BDD [+] 98], however it is unknown\nwhether all non-convex polyhedra have a general unfolding. In contrast, all convex polyhedra have a general\nunfolding [DO07, Sec. 24.1.1], but it is unknown whether they all have an edge unfolding [DO07, Ch. 22].\nPrior work on unfolding algorithms for non-convex objects has focused on orthogonal polyhedra. This\nclass consists of polyhedra whose edges and faces all meet at right angles. Because not all orthogonal\npolyhedra have edge unfoldings [BDD [+] 98], the unfolding algorithms typically use additional non-edge cuts\nthat follow one of two models. In the _grid unfolding model_, the surface is subdivided into rectangular _grid_\n_faces_ by adding edges where axis-perpendicular planes through each vertex intersect the surface, and cuts\nalong these added edges are also allowed. In the _grid refinement model_, each grid face under the grid unfolding\nmodel is further subdivided by an ( _a × b_ ) orthogonal grid, for some positive integers _a, b ≥_ 1, and cuts are\nalso allowed along any of these grid lines.\nA series of algorithms have been developed for unfolding arbitrary genus-0 orthogonal polyhedra, with\neach successive algorithm requiring less grid refinement. The first such algorithm [DFO07] required an\nexponential amount of grid refinement. This was reduced to quadratic refinement in [DDF14], and then to\nlinear in [CY15]. These ideas were further extended in [DDFO17] to unfold arbitrary genus-2 orthogonal\npolyhedra with linear refinement.\nThe only unfolding algorithms for orthogonal polyhedra that use sublinear refinement are for specialized orthogonal shape classes. For example, there exist algorithms for unfolding orthostacks using 1 _×_ 2\nrefinement [BDD [+] 98] and Manhattan Towers using 4 _×_ 5 refinement [DFO05]. There also exist unfolding algorithms for several classes of polyhedra composed of rectangular boxes. For example, orthotubes [BDD [+] 98]\nand one layer block structures [LPW14] built of unit cubes with an arbitrary number of unit holes can both\nbe unfolded with cuts restricted to the box edges. Our focus here is on a class of orthogonal polyhedra\nknown as polycube trees. A _polycube tree O_ is composed of axis-aligned unit cubes (boxes) glued face to\nface, whose surface is a 2-manifold and whose dual graph _T_ is a tree. (See Figure 1a for an example.) In the\ngrid unfolding model, cuts are allowed along any of the cube edges. Each node in _T_ is a box in _O_ and two\nnodes are connected by an edge if the corresponding boxes are adjacent in _O_ (i.e., if they share a face). In\nthis paper we will use the terms _box_ and _node_ interchangeably. The _degree_ of a box _b ∈O_ is defined as the\ndegree of its corresponding node in the dual tree _T_ . We select any node of degree one to be the _root_ of _T_ .\nIn a polycube tree, each box can be classified as either a _leaf_, a _connector_, or a _junction_ . A leaf is a box\nof degree one; a connector is a box of degree two whose two adjacent boxes are attached on opposite faces;\nall other boxes are junctions.\n∗Partial results for polycube trees (previously called _orthotrees_ ) of degree 3 or less have appeared in [DF18].\n†Department of Computer Science, Villanova University, Villanova, PA, `mirela.damian@villanova.edu`\n‡Department of Computer Science, Siena College, Loudonville, NY, `flatland@siena.edu`\n1\n(a) (b)\n|Col1|Col2|Col3|Col4|N<br>b|Col6|Col7|J<br>b|\n|---|---|---|---|---|---|---|---|\n|||||_Nb_|_Nb_|||\n|||||||||\n||||||||_Eb_|\n|_Wb_|_Wb_|||||||\n|_Wb_|_Wb_|||_b_||||\n|_Wb_||||||||\n|_Ib_|_Ib_|_Ib_|_Sb_|||||\nFigure 1: (a) A simple polycube tree example. Notation for: (b) _b_ ’s faces (c) _b_ ’s neighbors.\n_z_\n|entry<br>port<br>I|Col2|Col3|A|\n|---|---|---|---|\n|_I_<br>entry<br>port|port|||\n|entry<br>port<br>I|Col2|Col3|A|\n|---|---|---|---|\n|entry<br>_I_<br>~~port~~|~~port~~|||\n|entry<br>_I_<br>~~port~~|~~port~~|||\n|Col1|Col2|LA|N<br>A|Col5|Col6|\n|---|---|---|---|---|---|\n||_TA_|_TA_|_KA_|_BA_|_BA_|\n|||||||\n|||||_R_|_A_|\n|Col1|BA|Col3|N<br>A|\n|---|---|---|---|\n|_LA_|_LA_|_LA_|_LA_|\n|_LA_|_KA_|_KA_|_KA_|\n|_LA_|_TA_|_TA_|_RA_|\n|_LA_|_TA_|_TA_||\n|_LA_|_TA_|||\nFigure 2: (a) Head-first and (b) Hand-first unfolding of leaf box; dark-shaded pieces can be removed without\ndisconnecting the nets.\nBecause polycube trees are orthogonal polyhedra, they can be unfolded using the general algorithm\nin [CY15] with linear refinement. Algorithms for unfolding polycube trees using less than linear refinement\nhave been limited to polycube trees that are _well-separated_, meaning that no two junction boxes are adjacent.\nIn [DFMO05], the authors provide an algorithm for grid unfolding well-separated polycube trees. Recent\nwork in [HCY17] shows that the related class of well-separated orthographs (which allow arbitrary genus)\ncan be unfolded with a 2 _×_ 1 refinement.\nIn this paper we provide an algorithm for unfolding all polycube trees using a 4 _×_ 4 refinement of the\ncube faces. For each box _b_ in _T_, the algorithm unfolds _b_ and the boxes in the subtree rooted at _b_ recursively.\nIntuitively, the algorithm unfolds surface pieces of _b_ along a carefully constructed path. When the path\nreaches a child box of _b_, the child is recursively unfolded and then the path continues on _b_ again to the next\nchild (if there is one). The unfolding of _b_ and its subtree is contained within a rectangular region having two\nstaircase-like bites taken out of it. This is the first sublinear refinement unfolding result for the class of all\npolycube trees, regardless of whether they are well-separated or not.",
  "results": "This section introduces our main result, which uses **Theorem** 1 below. We note here that **Theorem** 1\nmakes references to upcoming lemmas, which are organized into separate sections for clarity and ease of\nreference. So the main role of **Theorem** 1 is to organize all unfolding cases into a structure that outlines\nthe proof technique detailed in subsequent sections.\n**Theorem 1.** _Any box A ∈T other than the root satisfies invariants (I1)-(I3) (listed in Section 5)._\n_Proof._ The proof is by strong induction on the height _h_ of _TA_ . The base case corresponds to _h_ = 0 (i.e, _A_\nis a leaf).\nConsider the unfolding of leaf box _A_ depicted in Figure 2a: starting at _A_ ’s entry port, the unfolding path\nsimply moves Head-first until it reaches _A_ ’s exit port. We now show that, when laid flat in the plane, the\nopen faces of _A_ form a net _NA_ that satisfies invariants (I1)-(I3). First note that the net _NA_ from Figure 2a\nfits within the inductive region and includes all open faces of _A_, therefore invariant (I1) is satisfied. To check\n(I2), observe that _NA_ provides type-1 entry and exit connections, since _e_ _[′]_ _∈_ _TA_ and _x_ _[′]_ _∈_ _BA_ are positioned\nalongside the entry and exit ports. To check (I3), observe that the open ring faces of _A_ not used in _A_ ’s entry\nor exit connections are the dark-shaded pieces from Figure 2a, and their removal does not disconnect _NA_ .\nThus _NA_ also satisfies all three invariants.\nThe inductive hypothesis states that the theorem holds for any dual subtree of height _h_ or less. To prove\nthe inductive step, we consider a dual subtree _TA_ of height _h_ + 1, and prove that the theorem holds for the\nroot _A_ of _TA_ .\nFirst note that, because _A_ is not the root of _T_, _A_ has a parent in _T_ . Also, since the height of _TA_ is\nat least 1, _A_ has at least one child in _TA_ . By the inductive hypothesis, each child of _A_ satisfies invariants\n(I1)-(I3). We discuss five cases, depending on the degree of _A_ .\n1. _A_ is of degree 2: this case is settled by **Theorem** 3.\n2. _A_ is of degree 3: this case is settled by **Theorem** 4.\n3. _A_ is of degree 4: this case is settled by **Theorem** 5.\n4. _A_ is of degree 5: this case is settled by **Theorem** 6.\n5. _A_ is of degree 6: this case is settled by **Theorem** 7.\nHaving exhausted all cases, we conclude the result of this theorem.\n**Theorem 2. [Main result.]** _Any polycube tree O can be unfolded into a net using a_ 4 _×_ 4 _refinement._\n_Proof._ Let _T_ be the dual tree of _O_ and let _A ∈T_ be the root of _T_ (by definition, _A_ is a node of degree one\nin _T_ ). Assume without loss of generality that _A_ has a back child _J_ (if this is not the case, reorient _O_ to\nmake this assumption hold). A recursive unfolding of _A_ is depicted in Figure 6a: starting Head-first on the\ntop face of _A_, the unfolding path recursively visits _J_ and returns to the bottom face of _A_ . The resulting net\ntakes the shape depicted in Figure 6b.\nBy **Theorem** 1, _J_ satisfies invariants (I1)-(I3), so its net _NJ_ takes the shape depicted in Figure 6b.\nNotice that _eJ ∈_ _TA_ and _xJ ∈_ _BA_ . Since _−→∈eJ_ _RA_ and _←−−∈xJ_ _LA_ are both open, the unit squares _EJ_ and _XJ_\n(occupied in Figure 6b by _RA_ and _LA_, respectively) do not belong to the inductive region for _J_ . Furthermore,\nsince _−→eJ_ and _←−−xJ_ are adjacent to _TJ_, invariant (I2) applied to _J_ tells us that _NJ_ provides either type-1 or\n7\n|J<br>start<br>A<br>end<br>(a)|Col2|Col3|\n|---|---|---|\n|end<br>start<br>_A_<br>_J_<br>(a)|start|start|\n|end<br>_A_|||\n|end<br>_A_|||\n|N J LA<br>BA<br>RA<br>TA<br>(b) FA N A|Col2|Col3|LA|BA|Col6|Col7|\n|---|---|---|---|---|---|---|\n|_FA_<br>_TA_<br>_RA_<br>_BA_<br>_LA_<br>_NJ_<br>(b)<br>_NA_|_FA_<br>_TA_<br>_RA_<br>_BA_<br>_LA_<br>_NJ_<br>(b)<br>_NA_|_FA_<br>_TA_<br>_RA_<br>_BA_<br>_LA_<br>_NJ_<br>(b)<br>_NA_|_LA_|_BA_|||\n|(b)|(b)|(b)|(b)|(b)|(b)|(b)|\n|(b)|_TA_||_RA_|_RA_|_RA_|_RA_|\n|(b)|_FA_|_FA_|_NA_|_NA_|_NA_|_NA_|\nFigure 6: Unfolding of root _A_ with back child _J_ (a) unfolding path (b) unfolding net _NA_ .\ntype-2 entry and exit connections. If of type-1, the entry (exit) connection attaches to _TA_ ( _BA_ ); otherwise,\nit attaches to _RA_ ( _LA_ ). In either case, the surface piece _NA_ depicted in Figure 6b is connected. Invariant\n(I1) applied to _J_ tells us that _NJ_ is a net that includes all open faces in the subtree _TJ_ rooted at _J_ and uses\na 4 _×_ 4 refinement. This along with the fact that the open faces of _A_ attach to _NJ_ without overlap settles\nthis theorem.\nThe need for a 4 _×_ 4 refinement will become clear later in Section 7.2, where we discuss a case that requires\na 4-refinement along one dimension (depicted in Figure 10a).",
  "conclusion": "We show that every polycube tree can be unfolded with a 4 _×_ 4 refinement of the grid faces. This is the first\nresult on unfolding arbitrary polycube trees using a constant refinement of the grid. It is open whether all\npolycube trees can be grid-unfolded without any refinements."
}